# 字典树
## 一、定义
## 二、数据结构
### 1.存储形式
* son[ i ][ j ]：son[ i ][ j ]表示的是第i个父节点所连接用二维数组来存储树的结构，N代表的是节点的个数，M代表的是节点的值，对于字符串来说，M就是26，即a-z这26个字母。
* index：节点的索引。在构造字典树的过程中，会不断产生新节点，index就是给新节点一个索引编号。
* cnt[ i ]：cnt[ i ]可以表示一个序列被检索的次数，i是该序列的末尾节点。该数组视题意需求进行取舍。
### 2.操作
* 插入一个新序列（以小写字符串序列为例）
```C++
// 插入一个新序列，也就是插入每个字符的过程，若该字符不存在，则创建一个新节点。
void insert(char s[])
{
    int p = 0; // p表示根节点0
    for(int i = 0;s[i];i ++)
    {
        int t = s[i] - 'a';
        if(!son[p][t]) son[p][t] = ++idx; // 若该节点不存在，则创建新节点
        p = son[p][t];
    }
    cnt[p] ++;// 为插入的序列计次数
}
```
* 查询一个序列是否存在
```C++
// 查询一个序列是否存在或者出现次数，同插入的过程类似。
int query(char s[])
{
    int p = 0;
    for(int i = 0;s[i];i ++)
    {
        int t = s[i] - 'a';
        if(!son[p][t]) return 0;// 遍历到某个节点不存在
        p = son[p][t];
    }
    return cnt[p];
}
```
## 三、应用
*  序列检索：用于查询某个序列是否存在。
*  序列出现次数统计：用于查询某个序列在给定集合中出现的次数，搜索中用于文本词频统计。
*  前缀匹配：找出一个集合中所有以某个前缀开头的序列，搜索中用于搜索提示。
## 四、题目
1. 最大异或对
* 题意：在$N$个整数 $A_1,A_2,...,A_n$任意选取两个进行异或运算，求其最大值。 
* 范围：$1\leq N \leq 10^5$, $0 \leq A_i \leq 2^{31}$
* 算法：字典树+贪心
* 思路：暴力做法就是就是对于每个数$A_i$，与其剩余的$n - 1$个数分别进行异或，求其最大值，但这显然会超时。异或操作涉及到位运算，我们可以换种思路进行思考，一个32位的
