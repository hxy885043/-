# 字典树
## 一、定义
字典树是一个多叉树，直观地来讲，它其实是仿照人查翻字典的逻辑所生成的一个结构。它需要一个确定的字符集，字典树中每个序列的字符都必须来源于该字符集。例如假定一个字符集是a-z，其字典树的序列可以是abc，zac等等，但不能是Abz，因为A不属于该字符集。
## 二、数据结构
### 1.存储形式
* son[ i ][ j ]：i表示的是父节点，j表示的是父节点下子节点的值，例如字符的值通常标记为0-25，代表a-z。son[i][j]表示该索引为i的父节点它所连接值为j的的子节点索引值。
* index：节点的索引。在构造字典树的过程中，会不断产生新节点，index就是给新节点一个索引编号。
* cnt[ i ]：cnt[ i ]可以表示一个序列被检索的次数，i是该序列的末尾节点。该数组视题意需求进行取舍。
### 2.操作
* 插入一个新序列（以小写字符串序列为例）
```C++
// 插入一个新序列，也就是插入每个字符的过程，若该字符不存在，则创建一个新节点。
void insert(char s[])
{
    int p = 0; // p表示根节点0
    for(int i = 0;s[i];i ++)
    {
        int t = s[i] - 'a';
        if(!son[p][t]) son[p][t] = ++idx; // 若该节点不存在，则创建新节点
        p = son[p][t];
    }
    cnt[p] ++;// 为插入的序列计次数
}
```
* 查询一个序列是否存在
```C++
// 查询一个序列是否存在或者出现次数，同插入的过程类似。
int query(char s[])
{
    int p = 0;
    for(int i = 0;s[i];i ++)
    {
        int t = s[i] - 'a';
        if(!son[p][t]) return 0;// 遍历到某个节点不存在
        p = son[p][t];
    }
    return cnt[p];
}
```
## 三、应用
*  序列检索：用于查询某个序列是否存在。
*  序列出现次数统计：用于查询某个序列在给定集合中出现的次数，搜索中用于文本词频统计。
*  前缀匹配：找出一个集合中所有以某个前缀开头的序列，搜索中用于搜索提示。
## 四、题目
1. 最大异或对
* 题意：在$N$个整数 $A_1,A_2,...,A_n$任意选取两个进行异或运算，求其最大值。 
* 范围：$1\leq N \leq 10^5$, $0 \leq A_i \leq 2^{31}$
* 算法：字典树+贪心
* 思路：暴力做法就是对于每个数$ A_i$ ，与其剩余的 $n - 1$个数分别进行异或，求其最大值，时间复杂度$ O（n^2）$ ，但这显然会超时。我们想办法对第二层进行优化，也就是说对于一个数$A_i$，怎样在其余$n - 1$个数中快速找到一个数，使其两者异或值最大？可以采取贪心加字典树的方法进行优化。
* 贪心：异或涉及到位运算，我们可以从二进制角度进行考虑。例如我们要找与5异或后值最大的数（假定这个数的范围限制在0-15之间），5的二进制表示0110，那么另一个数取其每一位的相反数1001，可以保证每一位异或后的值都是1，那么得到的异或值会最大。因此我们可得到一个贪心的思路，从两个方面进行贪心，一是先满足每一位上能够取到它的相反数，若不能则取相同的数。二是从高位到低位遍历，先满足高位能够取到其相反数，再查看低位。
* 字典树：通过刚刚贪心的思路，我们可以通过建立字典树来帮助判断每一位的取值。把所有数的二进制序列插入字典树中。对于每一个数$A_i$，查询每一位上是否存在它的相反数，若存在，则从该节点往下走，否则，从另一个结点往下走。通过 $A_i$ 的范围可以得知字典树的长度不会超过31。
* 存储形式：son[M][2]：M为最大节点数，每个节点的取值为0,1，因此取为2。
```C++
// 将一个数看做01二进制序列插入
void insert(int x){
    int p = 0;
    for(int i = 30;i >= 0;i --){
        int t = (x >> i) & 1;
        if(!son[p][t]) son[p][t] = ++idx;
        p = son[p][t];
    }
}
// 边查询边记录最大结果
int query(int x){
    int res = 0;
    int p = 0;
    for(int i = 30;i >= 0;i --){ 
        int t = (x >> i) & 1;
        // 判断当前位置是否存在与其相反节点
        if(son[p][!t]){ 
          p = son[p][!t];
          res += 1 << i;
        }
        else p = son[p][t];
    }
    return res;
}
```
具体代码见
